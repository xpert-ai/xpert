/**
 * This file was auto-generated by openapi-typescript.
 * Do not make direct changes to the file.
 */

export interface paths {
    "/threads": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Create Thread
         * @description Create a thread.
         */
        post: operations["create_thread_threads_post"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/threads/search": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Search Threads
         * @description Search for threads.
         *
         *     This endpoint also functions as the endpoint to list all threads.
         */
        post: operations["search_threads_threads_search_post"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/threads/{thread_id}/state": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Thread State
         * @description Get state for a thread.
         *
         *     The latest state of the thread (i.e. latest checkpoint) is returned.
         */
        get: operations["get_latest_thread_state_threads__thread_id__state_get"];
        put?: never;
        /**
         * Update Thread State
         * @description Add state to a thread.
         */
        post: operations["update_thread_state_threads__thread_id__state_post"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/threads/{thread_id}/history": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Thread History
         * @description Get all past states for a thread.
         */
        get: operations["get_thread_history_threads__thread_id__history_get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/threads/{thread_id}/copy": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Copy Thread
         * @description Create a new thread with a copy of the state and checkpoints from an existing thread.
         */
        post: operations["copy_thread_post_threads__thread_id__copy_post"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/threads/{thread_id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Thread
         * @description Get a thread by ID.
         */
        get: operations["get_thread_threads__thread_id__get"];
        put?: never;
        post?: never;
        /**
         * Delete Thread
         * @description Delete a thread by ID.
         */
        delete: operations["delete_thread_threads__thread_id__delete"];
        options?: never;
        head?: never;
        /**
         * Patch Thread
         * @description Update a thread.
         */
        patch: operations["patch_thread_threads__thread_id__patch"];
        trace?: never;
    };
    "/threads/{thread_id}/runs": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * List Runs
         * @description List runs for a thread.
         */
        get: operations["list_runs_http_threads__thread_id__runs_get"];
        put?: never;
        /**
         * Create Background Run
         * @description Create a run in existing thread, return the run ID immediately. Don't wait for the final run output.
         */
        post: operations["create_run_threads__thread_id__runs_post"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/threads/{thread_id}/runs/stream": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Create Run, Stream Output
         * @description Create a run in existing thread. Stream the output.
         */
        post: operations["stream_run_threads__thread_id__runs_stream_post"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/threads/{thread_id}/runs/wait": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Create Run, Wait for Output
         * @description Create a run in existing thread. Wait for the final output and then return it.
         */
        post: operations["wait_run_threads__thread_id__runs_wait_post"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/threads/{thread_id}/runs/{run_id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get Run
         * @description Get a run by ID.
         */
        get: operations["get_run_http_threads__thread_id__runs__run_id__get"];
        put?: never;
        post?: never;
        /**
         * Delete Run
         * @description Delete a run by ID.
         */
        delete: operations["delete_run_threads__thread_id__runs__run_id__delete"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/threads/{thread_id}/runs/{run_id}/wait": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Wait for Run output
         * @description Wait for a run to finish, return the final output. If the run already finished, returns its final output immediately.
         */
        get: operations["join_run_http_threads__thread_id__runs__run_id__join_get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/threads/{thread_id}/runs/{run_id}/stream": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Stream output from Run
         * @description Join the output stream of an existing run. This endpoint streams output in real-time from a run similar to the /threads/__THREAD_ID__/runs/stream endpoint. Only output produced after this endpoint is called will be streamed.
         */
        get: operations["stream_run_http_threads__thread_id__runs__run_id__join_get"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/threads/{thread_id}/runs/{run_id}/cancel": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** Cancel Run */
        post: operations["cancel_run_http_threads__thread_id__runs__run_id__cancel_post"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/store/items": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Retrieve a single item. */
        get: operations["get_item"];
        /** Store or update an item. */
        put: operations["put_item"];
        post?: never;
        /** Delete an item. */
        delete: operations["delete_item"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/store/items/search": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** Search for items within a namespace prefix. */
        post: operations["search_items"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/store/namespaces": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** List namespaces with optional match conditions. */
        post: operations["list_namespaces"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
}
export type webhooks = Record<string, never>;
export interface components {
    schemas: {
        /** Run */
        Run: {
            /**
             * Run Id
             * Format: uuid
             * @description The ID of the run.
             */
            run_id: string;
            /**
             * Thread Id
             * Format: uuid
             * @description The ID of the thread.
             */
            thread_id: string;
            /**
             * Assistant Id
             * Format: uuid
             * @description The assistant that was used for this run.
             */
            assistant_id: string;
            /**
             * Created At
             * Format: date-time
             * @description The time the run was created.
             */
            created_at: string;
            /**
             * Updated At
             * Format: date-time
             * @description The last time the run was updated.
             */
            updated_at: string;
            /**
             * Status
             * @description The status of the run. One of 'pending', 'error', 'success', 'timeout', 'interrupted'.
             * @enum {string}
             */
            status: "pending" | "error" | "success" | "timeout" | "interrupted";
            /**
             * Metadata
             * @description The run metadata.
             */
            metadata: Record<string, never>;
            /** Kwargs */
            kwargs: Record<string, never>;
            /**
             * Multitask Strategy
             * @description Strategy to handle concurrent runs on the same thread.
             * @enum {string}
             */
            multitask_strategy: "reject" | "rollback" | "interrupt" | "enqueue";
        };
        /**
         * RunCreateStateful
         * @description Payload for creating a run.
         */
        RunCreateStateful: {
            /** @description The assistant ID or graph name to run. If using graph name, will default to first assistant created from that graph. */
            assistant_id: string;
            /**
             * PRO: Sandbox Environment Id
             * PRO: @description Sandbox environment ID to force using the specified container.
             */
            sandbox_environment_id?: string;
            /**
             * Input
             * @description The input to the graph.
             */
            input?: Record<string, never>[] | Record<string, never> | null;
            /**
             * Metadata
             * @description Metadata to assign to the run.
             */
            metadata?: Record<string, never>;
            /**
             * Config
             * @description The configuration for the assistant.
             */
            config?: {
                /** Tags */
                tags?: string[];
                /** Recursion Limit */
                recursion_limit?: number;
                /** Configurable */
                configurable?: Record<string, never>;
            };
            /**
             * Webhook
             * Format: uri
             * @description Webhook to call after LangGraph API call is done.
             */
            webhook?: string;
            /**
             * Interrupt Before
             * @description Nodes to interrupt immediately before they get executed.
             */
            interrupt_before?: "*" | string[];
            /**
             * Interrupt After
             * @description Nodes to interrupt immediately after they get executed.
             */
            interrupt_after?: "*" | string[];
            /**
             * Stream Mode
             * @description The stream mode(s) to use.
             * @default [
             *       "values"
             *     ]
             */
            stream_mode: ("values" | "messages" | "messages-tuple" | "updates" | "events" | "debug" | "custom")[] | ("values" | "messages" | "messages-tuple" | "updates" | "events" | "debug" | "custom");
            /**
             * Stream Subgraphs
             * @description Whether to stream output from subgraphs.
             * @default false
             */
            stream_subgraphs: boolean;
            /**
             * On Disconnect
             * @description The disconnect mode to use. Must be one of 'cancel' or 'continue'.
             * @default cancel
             * @enum {string}
             */
            on_disconnect: "cancel" | "continue";
            /**
             * Feedback Keys
             * @description Feedback keys to assign to run.
             */
            feedback_keys?: string[];
            /**
             * Multitask Strategy
             * @description Multitask strategy to use. Must be one of 'reject', 'interrupt', 'rollback', or 'enqueue'.
             * @default reject
             * @enum {string}
             */
            multitask_strategy: "reject" | "rollback" | "interrupt" | "enqueue";
            /**
             * If Not Exists
             * @description How to handle missing thread. Must be either 'reject' (raise error if missing), or 'create' (create new thread).
             * @default reject
             * @enum {string}
             */
            if_not_exists: "create" | "reject";
            /**
             * After Seconds
             * @description The number of seconds to wait before starting the run. Use to schedule future runs.
             */
            after_seconds?: number;
        };
        /**
         * ThreadSearchRequest
         * @description Payload for listing threads.
         */
        ThreadSearchRequest: {
            /**
             * Metadata
             * @description Thread metadata to filter on.
             */
            metadata?: Record<string, never>;
            /**
             * Values
             * @description State values to filter on.
             */
            values?: Record<string, never>;
            /**
             * Status
             * @description Thread status to filter on.
             * @enum {string}
             */
            status?: "idle" | "busy" | "interrupted" | "error";
            /**
             * Limit
             * @description Maximum number to return.
             * @default 10
             */
            limit: number;
            /**
             * Offset
             * @description Offset to start from.
             * @default 0
             */
            offset: number;
        };
        /** Thread */
        Thread: {
            /**
             * Thread Id
             * Format: uuid
             * @description The ID of the thread.
             */
            thread_id: string;
            /**
             * Created At
             * Format: date-time
             * @description The time the thread was created.
             */
            created_at: string;
            /**
             * Updated At
             * Format: date-time
             * @description The last time the thread was updated.
             */
            updated_at: string;
            /**
             * Metadata
             * @description The thread metadata.
             */
            metadata: Record<string, never>;
            /**
             * Status
             * @description The status of the thread.
             * @enum {string}
             */
            status: "idle" | "busy" | "interrupted" | "error";
            /**
             * Values
             * @description The current state of the thread.
             */
            values?: Record<string, never>;
        };
        /**
         * ThreadCreate
         * @description Payload for creating a thread.
         */
        ThreadCreate: {
            /**
             * Thread Id
             * Format: uuid
             * @description The ID of the thread. If not provided, a random UUID will be generated.
             */
            thread_id?: string;
            /**
             * Metadata
             * @description Metadata to add to thread.
             */
            metadata?: Record<string, never>;
            /**
             * If Exists
             * @description How to handle duplicate creation. Must be either 'raise' (raise error if duplicate), or 'do_nothing' (return existing thread).
             * @default raise
             * @enum {string}
             */
            if_exists: "raise" | "do_nothing";
        };
        /**
         * ThreadPatch
         * @description Payload for creating a thread.
         */
        ThreadPatch: {
            /**
             * Metadata
             * @description Metadata to merge with existing thread metadata.
             */
            metadata?: Record<string, never>;
        };
        /** ThreadState */
        ThreadState: {
            /** Values */
            values: Record<string, never>[] | Record<string, never>;
            /** Next */
            next: string[];
            /** Tasks */
            tasks?: {
                /** Task Id */
                id: string;
                /** Node Name */
                name: string;
                /** Error */
                error?: string;
                interrupts?: unknown[];
                /** Checkpoint */
                checkpoint?: components["schemas"]["CheckpointConfig"];
                state?: components["schemas"]["ThreadState"];
            }[];
            /** Checkpoint */
            checkpoint: components["schemas"]["CheckpointConfig"];
            /** Metadata */
            metadata: Record<string, never>;
            /** Created At */
            created_at: string;
            /** Parent Checkpoint */
            parent_checkpoint?: Record<string, never>;
        };
        /**
         * ThreadStateUpdate
         * @description Payload for updating the state of a thread.
         */
        ThreadStateUpdate: {
            /**
             * Values
             * @description The values to update the state with.
             */
            values?: Record<string, never> | null;
            /**
             * Checkpoint
             * @description The checkpoint to update the state of.
             */
            checkpoint?: components["schemas"]["CheckpointConfig"];
        };
        /**
         * ThreadStateUpdateResponse
         * @description Response for adding state to a thread.
         */
        ThreadStateUpdateResponse: {
            /** Checkpoint */
            checkpoint?: Record<string, never>;
        };
        /**
         * CheckpointConfig
         * @description Checkpoint config.
         */
        CheckpointConfig: {
            /** @description Unique identifier for the thread associated with this checkpoint. */
            thread_id?: string;
            /** @description Namespace for the checkpoint, used for organization and retrieval. */
            checkpoint_ns?: string;
            /** @description Optional unique identifier for the checkpoint itself. */
            checkpoint_id?: string;
            /** @description Optional dictionary containing checkpoint-specific data. */
            checkpoint_map?: Record<string, never>;
        };
        /**
         * StorePutRequest
         * @description Request to store or update an item.
         */
        StorePutRequest: {
            /**
             * Namespace
             * @description A list of strings representing the namespace path.
             */
            namespace: string[];
            /**
             * Key
             * @description The unique identifier for the item within the namespace.
             */
            key: string;
            /**
             * Value
             * @description A dictionary containing the item's data.
             */
            value: Record<string, never>;
        };
        /**
         * StoreDeleteRequest
         * @description Request to delete an item.
         */
        StoreDeleteRequest: {
            /**
             * Namespace
             * @description A list of strings representing the namespace path.
             */
            namespace?: string[];
            /**
             * Key
             * @description The unique identifier for the item.
             */
            key: string;
        };
        /**
         * StoreSearchRequest
         * @description Request to search for items within a namespace prefix.
         */
        StoreSearchRequest: {
            /**
             * Namespace Prefix
             * @description List of strings representing the namespace prefix.
             */
            namespace_prefix?: string[] | null;
            /**
             * Filter
             * @description Optional dictionary of key-value pairs to filter results.
             */
            filter?: {
                [key: string]: unknown;
            } | null;
            /**
             * Limit
             * @description Maximum number of items to return (default is 10).
             * @default 10
             */
            limit: number;
            /**
             * Offset
             * @description Number of items to skip before returning results (default is 0).
             * @default 0
             */
            offset: number;
        };
        StoreListNamespacesRequest: {
            /**
             * Prefix
             * @description Optional list of strings representing the prefix to filter namespaces.
             */
            prefix?: string[];
            /**
             * Suffix
             * @description Optional list of strings representing the suffix to filter namespaces.
             */
            suffix?: string[];
            /**
             * Max Depth
             * @description Optional integer specifying the maximum depth of namespaces to return.
             */
            max_depth?: number;
            /**
             * Limit
             * @description Maximum number of namespaces to return (default is 100).
             * @default 100
             */
            limit: number;
            /**
             * Offset
             * @description Number of namespaces to skip before returning results (default is 0).
             * @default 0
             */
            offset: number;
        };
        /** @description Represents a single document or data entry in the graph's Store. Items are used to store cross-thread memories. */
        Item: {
            /** @description The namespace of the item. A namespace is analogous to a document's directory. */
            namespace: string[];
            /** @description The unique identifier of the item within its namespace. In general, keys needn't be globally unique. */
            key: string;
            /** @description The value stored in the item. This is the document itself. */
            value: Record<string, never>;
            /**
             * Format: date-time
             * @description The timestamp when the item was created.
             */
            created_at: string;
            /**
             * Format: date-time
             * @description The timestamp when the item was last updated.
             */
            updated_at: string;
        };
        SearchItemsResponse: {
            items: components["schemas"]["Item"][];
        };
        ListNamespaceResponse: string[][];
        /**
         * ErrorResponse
         * @description Error message returned from the server
         */
        ErrorResponse: string;
    };
    responses: {
        /** @description Successful retrieval of an item. */
        GetItemResponse: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": components["schemas"]["Item"];
            };
        };
        /** @description Item successfully stored or updated. */
        PutItemResponse: {
            headers: {
                [name: string]: unknown;
            };
            content?: never;
        };
        /** @description Item successfully deleted. */
        DeleteItemResponse: {
            headers: {
                [name: string]: unknown;
            };
            content?: never;
        };
        /** @description Successful search operation. */
        SearchItemsResponse: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": components["schemas"]["SearchItemsResponse"];
            };
        };
        /** @description Successful retrieval of namespaces. */
        ListNamespacesResponse: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": components["schemas"]["ListNamespaceResponse"];
            };
        };
        /** @description An error occurred. */
        ErrorResponse: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": components["schemas"]["ErrorResponse"];
            };
        };
    };
    parameters: never;
    requestBodies: never;
    headers: never;
    pathItems: never;
}
export type $defs = Record<string, never>;
export interface operations {
    create_thread_threads_post: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["ThreadCreate"];
            };
        };
        responses: {
            /** @description Success */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Thread"];
                };
            };
            /** @description Conflict */
            409: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    search_threads_threads_search_post: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["ThreadSearchRequest"];
            };
        };
        responses: {
            /** @description Success */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Thread"][];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    get_latest_thread_state_threads__thread_id__state_get: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The ID of the thread. */
                thread_id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Success */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ThreadState"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    update_thread_state_threads__thread_id__state_post: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The ID of the thread. */
                thread_id: string;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["ThreadStateUpdate"];
            };
        };
        responses: {
            /** @description Success */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ThreadStateUpdateResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    get_thread_history_threads__thread_id__history_get: {
        parameters: {
            query?: {
                limit?: number;
                before?: string;
            };
            header?: never;
            path: {
                /** @description The ID of the thread. */
                thread_id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Success */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ThreadState"][];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    copy_thread_post_threads__thread_id__copy_post: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The ID of the thread. */
                thread_id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Success */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Thread"];
                };
            };
            /** @description Conflict */
            409: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    get_thread_threads__thread_id__get: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The ID of the thread. */
                thread_id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Success */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Thread"];
                };
            };
            /** @description Not Found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    delete_thread_threads__thread_id__delete: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The ID of the thread. */
                thread_id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Success */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": unknown;
                };
            };
            /** @description Not Found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    patch_thread_threads__thread_id__patch: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The ID of the thread. */
                thread_id: string;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["ThreadPatch"];
            };
        };
        responses: {
            /** @description Success */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Thread"];
                };
            };
            /** @description Not Found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    list_runs_http_threads__thread_id__runs_get: {
        parameters: {
            query?: {
                limit?: number;
                offset?: number;
            };
            header?: never;
            path: {
                /** @description The ID of the thread. */
                thread_id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Success */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Run"][];
                };
            };
            /** @description Not Found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    create_run_threads__thread_id__runs_post: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The ID of the thread. */
                thread_id: string;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["RunCreateStateful"];
            };
        };
        responses: {
            /** @description Success */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Run"];
                };
            };
            /** @description Not Found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
            /** @description Conflict */
            409: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    stream_run_threads__thread_id__runs_stream_post: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The ID of the thread. */
                thread_id: string;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["RunCreateStateful"];
            };
        };
        responses: {
            /** @description Success */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": unknown;
                };
            };
            /** @description Not Found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
            /** @description Conflict */
            409: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    wait_run_threads__thread_id__runs_wait_post: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The ID of the thread. */
                thread_id: string;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["RunCreateStateful"];
            };
        };
        responses: {
            /** @description Success */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": unknown;
                };
            };
            /** @description Not Found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
            /** @description Conflict */
            409: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    get_run_http_threads__thread_id__runs__run_id__get: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The ID of the thread. */
                thread_id: string;
                /** @description The ID of the run. */
                run_id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Success */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Run"];
                };
            };
            /** @description Not Found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    delete_run_threads__thread_id__runs__run_id__delete: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The ID of the thread. */
                thread_id: string;
                /** @description The ID of the run. */
                run_id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Success */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": unknown;
                };
            };
            /** @description Not Found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    join_run_http_threads__thread_id__runs__run_id__join_get: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The ID of the thread. */
                thread_id: string;
                /** @description The ID of the run. */
                run_id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Success */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": unknown;
                };
            };
            /** @description Not Found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    stream_run_http_threads__thread_id__runs__run_id__join_get: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The ID of the thread. */
                thread_id: string;
                /** @description The ID of the run. */
                run_id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Success */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": unknown;
                };
            };
            /** @description Not Found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    cancel_run_http_threads__thread_id__runs__run_id__cancel_post: {
        parameters: {
            query?: {
                wait?: boolean;
                /** @description Action to take when cancelling the run. Possible values are `interrupt` or `rollback`. `interrupt` will simply cancel the run. `rollback` will cancel the run and delete the run and associated checkpoints afterwards. */
                action?: "interrupt" | "rollback";
            };
            header?: never;
            path: {
                /** @description The ID of the thread. */
                thread_id: string;
                /** @description The ID of the run. */
                run_id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Success */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": unknown;
                };
            };
            /** @description Not Found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    get_item: {
        parameters: {
            query: {
                key: string;
                namespace?: string[];
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Success */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Item"];
                };
            };
            /** @description Bad Request */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    put_item: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["StorePutRequest"];
            };
        };
        responses: {
            /** @description Success */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    delete_item: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["StoreDeleteRequest"];
            };
        };
        responses: {
            /** @description Success */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    search_items: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["StoreSearchRequest"];
            };
        };
        responses: {
            /** @description Success */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["SearchItemsResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    list_namespaces: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["StoreListNamespacesRequest"];
            };
        };
        responses: {
            /** @description Success */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ListNamespaceResponse"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
}
