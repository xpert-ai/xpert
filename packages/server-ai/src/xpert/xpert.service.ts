import {
	ChecklistItem,
	convertToUrlPath,
	ICopilotStore,
	IUser,
	IWFNTrigger,
	IXpert,
	IXpertAgentExecution,
	LongTermMemoryTypeEnum,
	OrderTypeEnum,
	STATE_VARIABLE_HUMAN,
	TMemoryQA,
	TMemoryUserProfile,
	TXpertTeamDraft,
	WorkflowNodeTypeEnum
} from '@metad/contracts'
import { getErrorMessage } from '@metad/server-common'
import {
	OptionParams,
	PaginationParams,
	RedisLockService,
	RequestContext,
	TenantOrganizationAwareCrudService,
	transformWhere,
	UserPublicDTO,
	UserService
} from '@metad/server-core'
import { InjectQueue } from '@nestjs/bull'
import { HttpException, HttpStatus, Injectable, Logger, NotFoundException, OnModuleInit } from '@nestjs/common'
import { CommandBus, QueryBus } from '@nestjs/cqrs'
import { EventEmitter2 } from '@nestjs/event-emitter'
import { InjectRepository } from '@nestjs/typeorm'
import { WorkflowTriggerRegistry } from '@xpert-ai/plugin-sdk'
import { Queue } from 'bull'
import { assign, uniq, uniqBy } from 'lodash'
import { FindOptionsWhere, In, IsNull, Like, Not, Repository } from 'typeorm'
import { CopilotStoreBulkPutCommand } from '../copilot-store'
import { CopilotStoreService } from '../copilot-store/copilot-store.service'
import { GetXpertWorkspaceQuery, MyXpertWorkspaceQuery } from '../xpert-workspace'
import { XpertPublishCommand } from './commands'
import { XpertIdentiDto } from './dto'
import { GetXpertMemoryEmbeddingsQuery } from './queries'
import { EventNameXpertValidate, QUEUE_XPERT_TRIGGER, TTriggerJob, XpertDraftValidateEvent } from './types'
import { FreeNodeValidator } from './validators'
import { Xpert } from './xpert.entity'

@Injectable()
export class XpertService extends TenantOrganizationAwareCrudService<Xpert> implements OnModuleInit {
	readonly #logger = new Logger(XpertService.name)

	constructor(
		@InjectRepository(Xpert)
		public readonly repository: Repository<Xpert>,
		private readonly storeService: CopilotStoreService,
		private readonly userService: UserService,
		private readonly commandBus: CommandBus,
		private readonly queryBus: QueryBus,
		private readonly eventEmitter: EventEmitter2,
		private readonly triggerRegistry: WorkflowTriggerRegistry,
		private readonly redisLockService: RedisLockService,
		@InjectQueue(QUEUE_XPERT_TRIGGER)
		private triggerQueue: Queue<TTriggerJob>
	) {
		super(repository)
	}

	async onModuleInit() {
		const { items } = await this.findAll({ where: { latest: true, publishAt: Not(IsNull()) } })
		for (const xpert of items) {
			const triggers = xpert.graph?.nodes?.filter(
				(node) =>
					node.type === 'workflow' &&
					node.entity.type === WorkflowNodeTypeEnum.TRIGGER &&
					(<IWFNTrigger>node.entity).from !== 'chat'
			)
			if (triggers?.length) {
				const lockId = await this.redisLockService.acquireLock('job:trigger:' + xpert.id, 10000)
				if (!lockId) {
					continue
				}
				await this.publishTriggers(xpert)
			}
		}
	}

	/**
	 * To solve the problem that Update cannot create OneToOne relation, it is uncertain whether using save to update might pose risks
	 */
	async update(id: string, entity: Partial<Xpert>) {
		const _entity = await super.findOne(id)
		assign(_entity, entity)
		return await this.repository.save(_entity)
	}

	/**
	 * Verify the uniqueness of the slug generated by Name in the system to ensure that it is unique across the entire database
	 *
	 * @param name
	 * @returns
	 */
	async validateName(name: string) {
		const slug = convertToUrlPath(name)
		if (slug.length < 5) {
			return false
		}
		const count = await this.repository.count({
			where: {
				slug,
				latest: true
			}
		})

		return !count
	}

	async getAllByWorkspace(workspaceId: string, data: PaginationParams<Xpert>, published: boolean, user: IUser) {
		const { select, relations, order, take } = data ?? {}
		let { where } = data ?? {}
		where = transformWhere(where ?? {})
		if (workspaceId === 'null' || workspaceId === 'undefined' || !workspaceId) {
			where = {
				...(<FindOptionsWhere<Xpert>>where),
				workspaceId: IsNull(),
				createdById: user.id
			}
		} else {
			const workspace = await this.queryBus.execute(new GetXpertWorkspaceQuery(user, { id: workspaceId }))
			if (!workspace) {
				throw new NotFoundException(`Not found or no auth for xpert workspace '${workspaceId}'`)
			}

			where = {
				...(<FindOptionsWhere<Xpert>>where),
				workspaceId: workspaceId
			}
		}
		if (published) {
			where.version = Not(IsNull())
		}

		return this.findAll({
			select,
			where,
			relations,
			order,
			take
		})
	}

	async getMyAll(params: PaginationParams<Xpert>) {
		const userId = RequestContext.currentUserId()
		const { items: userWorkspaces } = await this.queryBus.execute(new MyXpertWorkspaceQuery(userId, {}))

		const { relations, order, take } = params ?? {}
		let { where } = params ?? {}
		where = where ?? {}

		where = {
			...(<FindOptionsWhere<Xpert>>where),
			publishAt: Not(IsNull()),
			createdById: userId
		}

		const xpertsCreatedByUser = await this.findAll({
			where,
			relations,
			order,
			take
		})

		const baseQuery = this.repository
			.createQueryBuilder('xpert')
			.innerJoin('xpert.managers', 'manager', 'manager.id = :userId', { userId })
		// add relations
		relations?.forEach((relation) => baseQuery.leftJoinAndSelect('xpert.' + relation, relation))
		if (order) {
			Object.keys(order).forEach((name) => {
				baseQuery.addOrderBy(`xpert.${name}`, order[name])
			})
		}
		const xpertsManagedByUser = await baseQuery
			.where({
				...(params.where ?? {}),
				publishAt: Not(IsNull()),
				tenantId: RequestContext.currentTenantId(),
				organizationId: RequestContext.getOrganizationId()
			})
			.take(take)
			.getMany()

		const xpertsInUserWorkspaces = await this.repository.find({
			where: {
				...(params.where ?? {}),
				publishAt: Not(IsNull()),
				workspaceId: In(userWorkspaces.map((workspace) => workspace.id))
			},
			relations,
			order,
			take
		})

		const allXperts = uniqBy(
			[...xpertsCreatedByUser.items, ...xpertsManagedByUser, ...xpertsInUserWorkspaces],
			'id'
		)

		return {
			items: allXperts.map((item) => new XpertIdentiDto(item)),
			total: allXperts.length
		}
	}

	async getTeam(id: string, options?: OptionParams<Xpert>) {
		const { relations } = options ?? {}
		const team = await this.findOne(id, {
			relations: uniq([...(relations ?? []), 'agents', 'toolsets', 'knowledgebases'])
		})
		return team
	}

	async save(entity: Xpert) {
		return await this.repository.save(entity)
	}

	async saveDraft(id: string, draft: TXpertTeamDraft) {
		const xpert = await this.findOne(id)
		xpert.draft = {
			...draft,
			team: {
				...draft.team,
				updatedAt: new Date(),
				updatedById: RequestContext.currentUserId()
			}
		} as TXpertTeamDraft

		xpert.draft.checklist = await this.validate(xpert.draft)

		await this.repository.save(xpert)
		return xpert.draft
	}

	async updateDraft(id: string, draft: TXpertTeamDraft) {
		const xpert = await this.findOne(id)
		xpert.draft = {
			...(xpert.draft ?? {}),
			...draft,
			team: {
				...(xpert.draft?.team ?? {}),
				...(draft.team ?? {}),
				updatedAt: new Date(),
				updatedById: RequestContext.currentUserId()
			}
		} as TXpertTeamDraft

		xpert.draft.checklist = await this.validate(xpert.draft)

		await this.repository.save(xpert)
		return xpert.draft
	}

	async validate(draft: TXpertTeamDraft) {
		const freeNodeValidator = new FreeNodeValidator()

		const results: ChecklistItem[] = []

		const res = await freeNodeValidator.validate(draft)
		results.push(...res)

		// More validators events
		const validators = await this.eventEmitter.emitAsync(EventNameXpertValidate, new XpertDraftValidateEvent(draft))
		validators.forEach((items) => {
			if (items) {
				results.push(...items)
			}
		})
		return results
	}

	async publish(id: string, newVersion: boolean, environmentId: string, notes: string) {
		return await this.commandBus.execute(new XpertPublishCommand(id, newVersion, environmentId, notes))
	}

	async allVersions(id: string) {
		const xpert = await this.findOne(id)
		const { items: allVersions } = await this.findAll({
			where: {
				workspaceId: xpert.workspaceId ?? IsNull(),
				type: xpert.type,
				slug: xpert.slug
			}
		})

		return allVersions.map((item) => ({
			id: item.id,
			version: item.version,
			latest: item.latest,
			publishAt: item.publishAt,
			releaseNotes: item.releaseNotes
		}))
	}

	async setAsLatest(id: string) {
		const xpert = await this.findOne(id)
		if (!xpert.latest) {
			const { items: xperts } = await this.findAll({
				where: {
					workspaceId: xpert.workspaceId ?? IsNull(),
					type: xpert.type,
					slug: xpert.slug,
					latest: true
				}
			})

			xperts.forEach((item) => (item.latest = false))
			xpert.latest = true
			await this.repository.save([...xperts, xpert])
		}
	}

	async deleteXpert(id: string) {
		const xpert = await this.findOne(id)

		if (xpert.latest) {
			// Delete all versions if it is latest version
			return await this.softDelete({ name: xpert.name, deletedAt: IsNull() })
		} else {
			// Delete current version team
			return await this.softDelete(xpert.id)
		}
	}

	async updateManagers(id: string, ids: string[]) {
		const xpert = await this.findOne(id, { relations: ['managers'] })
		const { items } = await this.userService.findAll({ where: { id: In(ids) } })
		xpert.managers = items
		await this.repository.save(xpert)
		return xpert.managers.map((u) => new UserPublicDTO(u))
	}

	async removeManager(id: string, userId: string) {
		const xpert = await this.findOne(id, { relations: ['managers'] })
		if (!xpert) {
			throw new NotFoundException(`Xpert with id ${id} not found`)
		}

		const managerIndex = xpert.managers.findIndex((manager) => manager.id === userId)
		if (managerIndex === -1) {
			throw new NotFoundException(`Manager with id ${userId} not found in Xpert ${id}`)
		}

		xpert.managers.splice(managerIndex, 1)
		await this.repository.save(xpert)
	}

	async findBySlug(slug: string, relations?: string[]) {
		return await this.repository.findOne({
			where: {
				slug,
				latest: true,
				publishAt: Not(IsNull())
			},
			relations: uniq((relations ?? []).concat(['user', 'createdBy', 'organization']))
		})
	}

	async createMemory(xpertId: string, body: { type: LongTermMemoryTypeEnum; value: TMemoryQA | TMemoryUserProfile }) {
		const xpert = await this.findOne(xpertId, { relations: ['agent'] })
		const memory = xpert.memory
		const tenantId = RequestContext.currentTenantId()
		const organizationId = RequestContext.getOrganizationId()
		const execution: IXpertAgentExecution = {}
		const embeddings = await this.queryBus.execute(
			new GetXpertMemoryEmbeddingsQuery(tenantId, organizationId, memory, {
				tokenCallback: (token) => {
					execution.embedTokens += token ?? 0
				}
			})
		)

		await this.commandBus.execute(
			new CopilotStoreBulkPutCommand(
				body.type,
				[body.value],
				[xpertId, body.type || LongTermMemoryTypeEnum.QA],
				embeddings
			)
		)
	}

	async createBulkMemories(
		xpertId: string,
		body: { type: LongTermMemoryTypeEnum; memories: Array<TMemoryQA | TMemoryUserProfile> }
	) {
		const xpert = await this.findOne(xpertId, { relations: ['agent'] })
		const memory = xpert.memory
		const tenantId = RequestContext.currentTenantId()
		const organizationId = RequestContext.getOrganizationId()
		const execution: IXpertAgentExecution = {}
		const embeddings = await this.queryBus.execute(
			new GetXpertMemoryEmbeddingsQuery(tenantId, organizationId, memory, {
				tokenCallback: (token) => {
					execution.embedTokens += token ?? 0
				}
			})
		)
		await this.commandBus.execute(
			new CopilotStoreBulkPutCommand(
				body.type,
				body.memories,
				[xpertId, body.type || LongTermMemoryTypeEnum.QA],
				embeddings
			)
		)
	}

	async findAllMemory(id: string, types: string[]) {
		const where = {} as FindOptionsWhere<ICopilotStore>
		const _types = types
		if (_types?.length > 1) {
			where.prefix = In(_types.map((type) => `${id}${type ? `:${type}` : ''}`))
		} else if (_types?.length === 1) {
			const type = _types[0]
			where.prefix = `${id}${type ? `:${type}` : ''}`
		} else {
			where.prefix = Like(`${id}%`)
		}

		try {
			return await this.storeService.findAll({
				where,
				relations: ['createdBy'],
				order: { createdAt: OrderTypeEnum.DESC }
			})
		} catch (err) {
			throw new HttpException(getErrorMessage(err), HttpStatus.INTERNAL_SERVER_ERROR)
		}
	}

	async getTriggerProviders() {
		return this.triggerRegistry.list().map((provider) => ({
			...provider.meta
		}))
	}

	async publishTriggers(xpert: IXpert) {
		const triggers = xpert.graph.nodes
			.filter((_) => _.type === 'workflow' && _.entity.type === WorkflowNodeTypeEnum.TRIGGER)
			.map((node) => node.entity as IWFNTrigger)
			.filter((node) => node.from && node.from !== 'chat')
		for await (const node of triggers) {
			let provider
			try {
				provider = this.triggerRegistry.get(node.from)
			} catch (err) {
				continue
			}
			provider.publish(
				{
					xpertId: xpert.id,
					config: node.config
				},
				(payload) => {
					// Handle the payload if needed
					console.log(`Trigger '${node.from}' executed with payload:`, payload)
					this.addTriggerJob(xpert.id, null, payload, node).catch((err) => {
						this.#logger.error(`Add trigger job error: ${getErrorMessage(err)}`)
					})
				}
			)
		}
	}

	async addTriggerJob(
		xpertId: string,
		userId: string,
		state: {
			[STATE_VARIABLE_HUMAN]: Record<string, any>
			[key: string]: any
		},
		trigger: IWFNTrigger
	) {
		await this.triggerQueue.add({
			userId: userId,
			xpertId,
			state,
			from: 'knowledge',
			trigger: trigger
		})
	}
}
